From 45fc64505971f82d5f3a09f1cf13dd9146ceec6e Mon Sep 17 00:00:00 2001
From: Wright Feng <wright.feng@cypress.com>
Date: Thu, 2 Jul 2020 22:10:45 -0500
Subject: [PATCH 128/130] brcmfmac: fix kernel panic when allocating escan_buf
 failed

In Android build, we should not free all pointers related to
primary interface. Therefore, we skip freeing wiphy, ops, config when
hitting allocation failed.
And to avoid waiting too long for bus ready, we wake up pending thread
no matter bus starts successully or not.

Signed-off-by: Wright Feng <wright.feng@cypress.com>

---
 .../broadcom/brcm80211/brcmfmac/android.h     |  4 +++
 .../broadcom/brcm80211/brcmfmac/cfg80211.c    |  8 +++++
 .../broadcom/brcm80211/brcmfmac/core.c        | 33 ++++++++++++-------
 3 files changed, 33 insertions(+), 12 deletions(-)

diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/android.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/android.h
index 8752ad22ae29..64994c5c854f 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/android.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/android.h
@@ -59,6 +59,10 @@ struct brcmf_android_wifi_priv_cmd {
 
 #define DOT11_OUI_LEN		3	/* d11 OUI length */
 
+#define RS_FAILED	(-1)
+#define RS_OK		(0)
+#define RS_INIT		(1)
+
 #if defined(CONFIG_BRCMFMAC_ANDROID)
 struct brcmf_android {
 	struct brcmf_pub *drvr;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index f181fa247a45..ed3865b2fa93 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -8018,7 +8018,9 @@ struct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,
 	err = wl_init_priv(cfg);
 	if (err) {
 		bphy_err(drvr, "Failed to init iwm_priv (%d)\n", err);
+#ifndef CONFIG_BRCMFMAC_ANDROID
 		brcmf_free_vif(vif);
+#endif
 		goto wiphy_out;
 	}
 	ifp->vif = vif;
@@ -8146,14 +8148,20 @@ struct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,
 	brcmf_btcoex_detach(cfg);
 	brcmf_p2p_detach(&cfg->p2p);
 wiphy_unreg_out:
+#ifndef CONFIG_BRCMFMAC_ANDROID
 	wiphy_unregister(cfg->wiphy);
+#endif
 priv_out:
 	wl_deinit_priv(cfg);
+#ifndef CONFIG_BRCMFMAC_ANDROID
 	brcmf_free_vif(vif);
 	ifp->vif = NULL;
+#endif
 wiphy_out:
+#ifndef CONFIG_BRCMFMAC_ANDROID
 	brcmf_free_wiphy(wiphy);
 	kfree(cfg);
+#endif
 	return NULL;
 }
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
index 8629510e0a5a..1fd2a51bb793 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
@@ -1260,6 +1260,7 @@ static int brcmf_bus_started(struct brcmf_pub *drvr, struct cfg80211_ops *ops)
 	struct brcmf_bus *bus_if = drvr->bus_if;
 	struct brcmf_if *ifp;
 	struct brcmf_if *p2p_ifp;
+	struct brcmf_cfg80211_info *cfg;
 
 	brcmf_dbg(TRACE, "\n");
 
@@ -1295,12 +1296,13 @@ static int brcmf_bus_started(struct brcmf_pub *drvr, struct cfg80211_ops *ops)
 
 	brcmf_proto_add_if(drvr, ifp);
 
-	drvr->config = brcmf_cfg80211_attach(drvr, ops,
-					     drvr->settings->p2p_enable);
-	if (drvr->config == NULL) {
+	cfg = brcmf_cfg80211_attach(drvr, ops,
+				    drvr->settings->p2p_enable);
+	if (!cfg) {
 		ret = -ENOMEM;
 		goto fail;
 	}
+	drvr->config = cfg;
 
 #ifdef CONFIG_BRCMFMAC_ANDROID
 	brcmf_dbg(INFO, "set mac address %pM\n", ifp->mac_addr);
@@ -1357,14 +1359,15 @@ static int brcmf_bus_started(struct brcmf_pub *drvr, struct cfg80211_ops *ops)
 
 fail:
 	bphy_err(drvr, "failed: %d\n", ret);
-	if (drvr->config) {
+	if (drvr->config)
 		brcmf_cfg80211_detach(drvr->config);
-		drvr->config = NULL;
-	}
+#ifndef CONFIG_BRCMFMAC_ANDROID
+	drvr->config = NULL;
 	brcmf_net_detach(ifp->ndev, false);
+	drvr->iflist[0] = NULL;
+#endif
 	if (p2p_ifp)
 		brcmf_net_detach(p2p_ifp->ndev, false);
-	drvr->iflist[0] = NULL;
 	drvr->iflist[1] = NULL;
 	if (drvr->settings->ignore_probe_fail)
 		ret = 0;
@@ -2149,6 +2152,7 @@ int brcmf_android_netdev_open(struct net_device *ndev)
 			goto failed;
 		}
 
+		android->reset_status = RS_INIT;
 		if (brcmf_android_wifi_on(drvr, ndev)) {
 			brcmf_err("brcmf_android_wifi_on failed\n");
 			ret = -EIO;
@@ -2159,10 +2163,11 @@ int brcmf_android_netdev_open(struct net_device *ndev)
 			brcmf_dbg(INFO, "device reset, wait for bus ready");
 
 		timeout = wait_event_timeout(ifp->pend_dev_reset_wait,
-					     !brcmf_android_in_reset(drvr),
+					     (android->reset_status != RS_INIT),
 					     MAX_WAIT_FOR_BUS_START);
 
-		if (timeout && android->init_done && !android->reset_status) {
+		if (timeout && android->init_done &&
+		    android->reset_status == RS_OK) {
 			bus_if = drvr->bus_if;
 		} else {
 			brcmf_err("device reset failed\n");
@@ -2297,12 +2302,16 @@ void brcmf_wake_dev_reset_waitq(struct brcmf_pub *drvr, int status)
 {
 	struct brcmf_if *ifp = drvr->iflist[0];
 
-	drvr->android->reset_status = status;
-	brcmf_android_set_reset(drvr, false);
+	if (status) {
+		brcmf_err("reset failed, err=%d\n", status);
+		drvr->android->reset_status = RS_FAILED;
+	} else {
+		brcmf_android_set_reset(drvr, false);
+		drvr->android->reset_status = RS_OK;
+	}
 	/* wake up device reset wait queue */
 	if (waitqueue_active(&ifp->pend_dev_reset_wait)) {
 		brcmf_dbg(INFO, "device reset is done, wake up pending task\n");
-		brcmf_android_set_reset(drvr, false);
 		wake_up(&ifp->pend_dev_reset_wait);
 	}
 }
-- 
2.25.0

